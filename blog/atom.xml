<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张洋洋的个人博客</title>
  
  <subtitle>人品比技术更重要</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://zyycode.github.io/"/>
  <updated>2018-05-12T07:33:52.786Z</updated>
  <id>http://zyycode.github.io/</id>
  
  <author>
    <name>张洋洋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在服务器安装 Node.js</title>
    <link href="http://zyycode.github.io/2018/05/03/server-nodejs/"/>
    <id>http://zyycode.github.io/2018/05/03/server-nodejs/</id>
    <published>2018-05-03T03:23:07.000Z</published>
    <updated>2018-05-12T07:33:52.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在腾讯云服务器安装-Node-js-环境"><a href="#在腾讯云服务器安装-Node-js-环境" class="headerlink" title="在腾讯云服务器安装 Node.js 环境"></a>在腾讯云服务器安装 Node.js 环境</h1><p>之前在狼叔的live群众，看到腾讯云有个活动，价格优惠果断入手了一台来玩玩，但是一直没有时间，今天就从安装开始吧！ 🤔🤔🤔</p><h2 id="使用-ssh-远程连接服务器"><a href="#使用-ssh-远程连接服务器" class="headerlink" title="使用 ssh 远程连接服务器"></a>使用 ssh 远程连接服务器</h2><p>因为本人是使用 Windows 系统，所以需要下载一些终端工具（没有钱买MAC ☹️）。这样的工具挺多的，像 <a href="https://mobaxterm.mobatek.net/" target="_blank" rel="noopener">MobaXterm</a> 和 <a href="https://www.netsarang.com/products/xsh_overview.html" target="_blank" rel="noopener">Xshell</a><br>个人比较喜欢 MobaXterm 看起来比较舒服。<br>新建一个对话（session），填入你的服务器的 IP 地址和端口号，连接成功之后输入密码就可以了。</p><h2 id="通过-shell-安装-Node-js"><a href="#通过-shell-安装-Node-js" class="headerlink" title="通过 shell 安装 Node.js"></a>通过 shell 安装 Node.js</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 wget 安装方式</span></span><br><span class="line">wget https://npm.taobao.org/mirrors/node/v8.11.1/node-v8.11.1-linux-x64.tar.xz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">xz -d node-v8.11.1-linux-x64.tar.xz</span><br><span class="line">tar -xvf node-v8.11.1-linux-x64.tar</span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立软连接</span></span><br><span class="line">ln -s /node-v8.11.1-linux-x64/bin/node /usr/local/bin</span><br><span class="line">ln -s /node-v8.11.1-linux-x64/bin/npm /usr/local/bin</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-连接到远程服务器"><a href="#1-连接到远程服务器" class="headerlink" title="1. 连接到远程服务器"></a>1. 连接到远程服务器</h3><p>在本地连接到远程的 Linux 服务器，可以使用相关工具，如 MobaXterm 或 Xshell 等软件，输入 IP 地址和端口号，连接之后输入密码即可。<br><img src="/blog/2018/05/03/server-nodejs/node-install-1.png" alt="ssh连接服务器成功" title="ssh连接服务器成功"></p><h3 id="2-获取安装地址"><a href="#2-获取安装地址" class="headerlink" title="2. 获取安装地址"></a>2. 获取安装地址</h3><p>在 <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Node.js 中文网</a>获取安装路径，选择自己服务器的系统和位数，可以通过 <code>uname -a</code> 命令查看到我的 Linux 系统位数是 64 位（x86_64表示64位系统，i686 i386表示32位系统）。<br><img src="/blog/2018/05/03/server-nodejs/node-install-6.png" alt="Linux系统位数" title="Linux系统位数"><br>安装的链接地址可以在官网上通过鼠标右键进行复制。<br><img src="/blog/2018/05/03/server-nodejs/node-install-5.png" alt="安装地址" title="安装地址"><br> 复制之后可以使用 <code>wegt https://npm.taobao.org/mirrors/node/v8.11.1/node-v8.11.1-linux-x64.tar.xz</code> <strong>shell</strong> 命令进行安装。安装前可以新建一个 <strong>app</strong> 目录安装到该目录下。<br> <img src="/blog/2018/05/03/server-nodejs/node-install-2.png" alt="安装" title="安装"></p><h3 id="3-解压"><a href="#3-解压" class="headerlink" title="3. 解压"></a>3. 解压</h3><p>如果安装包是以<strong>xz</strong>结尾的，那么解压主要分为两步：<br>1) <code>xz -d node-v8.11.1-linux-x64.tar.xz</code><br>2) <code>tar -xvf node-v8.11.1-linux-x64.tar</code><br><img src="/blog/2018/05/03/server-nodejs/node-install-3.png" alt="解压" title="解压"></p><h3 id="4-建立软连接"><a href="#4-建立软连接" class="headerlink" title="4. 建立软连接"></a>4. 建立软连接</h3><p>其实到这一步，已经算是安装完成了，使用 <code>node -v</code> 和 <code>npm -v</code> 可以查看到安装的版本，但是在全局环境下会发现报错，所以需要建立<strong>软连接</strong>，就是将 Nodejs 安装 bin 目录下的可执行文件链接到 <code>/usr/local/bin</code> 或 <code>/usr/bin</code> 目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /node-v8.11.1-linux-x64/bin/node /usr/local/bin</span><br><span class="line">ln -s /node-v8.11.1-linux-x64/bin/npm /usr/local/bin</span><br></pre></td></tr></table></figure><p><img src="/blog/2018/05/03/server-nodejs/node-install-4.png" alt="建立软连接" title="建立软连接"><br>建立软连接成功之后，在全局环境下也可以执行 node 的相关命令了。</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>在使用 ssh 方式连接服务器是发现怎么都连不上，一直报连接超时错误，ping 又是通的，换了其它连接工具发现也不行，上网搜试过也不行，然后通过求助腾讯云客服，最后竟然是学校网络的问题. 🔪🔪🔪</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;在腾讯云服务器安装-Node-js-环境&quot;&gt;&lt;a href=&quot;#在腾讯云服务器安装-Node-js-环境&quot; class=&quot;headerlink&quot; title=&quot;在腾讯云服务器安装 Node.js 环境&quot;&gt;&lt;/a&gt;在腾讯云服务器安装 Node.js 环境&lt;/h1&gt;&lt;p&gt;之前在狼叔的live群众，看到腾讯云有个活动，价格优惠果断入手了一台来玩玩，但是一直没有时间，今天就从安装开始吧！ 🤔🤔🤔&lt;/p&gt;
&lt;h2 id=&quot;使用-ssh-远程连接服务器&quot;&gt;&lt;a href=&quot;#使用-ssh-远程连接服务器&quot; class=&quot;headerlink&quot; title=&quot;使用 ssh 远程连接服务器&quot;&gt;&lt;/a&gt;使用 ssh 远程连接服务器&lt;/h2&gt;&lt;p&gt;因为本人是使用 Windows 系统，所以需要下载一些终端工具（没有钱买MAC ☹️）。这样的工具挺多的，像 &lt;a href=&quot;https://mobaxterm.mobatek.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MobaXterm&lt;/a&gt; 和 &lt;a href=&quot;https://www.netsarang.com/products/xsh_overview.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Xshell&lt;/a&gt;&lt;br&gt;个人比较喜欢 MobaXterm 看起来比较舒服。&lt;br&gt;新建一个对话（session），填入你的服务器的 IP 地址和端口号，连接成功之后输入密码就可以了。&lt;/p&gt;
&lt;h2 id=&quot;通过-shell-安装-Node-js&quot;&gt;&lt;a href=&quot;#通过-shell-安装-Node-js&quot; class=&quot;headerlink&quot; title=&quot;通过 shell 安装 Node.js&quot;&gt;&lt;/a&gt;通过 shell 安装 Node.js&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 使用 wget 安装方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wget https://npm.taobao.org/mirrors/node/v8.11.1/node-v8.11.1-linux-x64.tar.xz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 解压&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xz -d node-v8.11.1-linux-x64.tar.xz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar -xvf node-v8.11.1-linux-x64.tar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 建立软连接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ln -s /node-v8.11.1-linux-x64/bin/node /usr/local/bin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ln -s /node-v8.11.1-linux-x64/bin/npm /usr/local/bin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="菜鸟成长记" scheme="http://zyycode.github.io/categories/%E8%8F%9C%E9%B8%9F%E6%88%90%E9%95%BF%E8%AE%B0/"/>
    
    
      <category term="服务器" scheme="http://zyycode.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nodejs" scheme="http://zyycode.github.io/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Win10 使用多桌面提升开发效率</title>
    <link href="http://zyycode.github.io/2018/05/01/Win10-split-screen/"/>
    <id>http://zyycode.github.io/2018/05/01/Win10-split-screen/</id>
    <published>2018-05-01T14:09:55.000Z</published>
    <updated>2018-05-12T05:26:21.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="巧用-Win10-分屏功能"><a href="#巧用-Win10-分屏功能" class="headerlink" title="巧用 Win10 分屏功能"></a>巧用 Win10 分屏功能</h1><p>一般我会新建三个桌面，一个看文档，一个写代码，另一个看调试结果。虽然可以在一个桌面中直接使用 <code>ALT + TAB</code> 组合键来进行切换，但是软件多起来就会发现很乱。使用分屏会更加简洁方便。<br>在切换桌面可以使用 <a href="http://www.yingdev.com/projects/wgestures" target="_blank" rel="noopener">WGestures</a> 软件，通过鼠标触碰桌面的左上角和右上角来进行切换上下桌面。安装后可以设置一下快捷键，当然也可以直接通过<code>Win+Ctrl+Left/Right</code>组合键来切换。如图：<br><a id="more"></a><br><img src="/blog/2018/05/01/Win10-split-screen/wgesture-1.png" alt="WGesture设置" title="WGesture设置"><br>vscode 使用全屏模式，左边的桌面可以查看文档，查资料，右边的桌面查看调试结果，中间的写代码，是不是很爽 😄<br><img src="/blog/2018/05/01/Win10-split-screen/20180501.gif" alt="使用分屏" title="使用分屏"><br>这里推荐一个 vscode 插件 <code>Live Server</code>，通过点击右下角的<strong>Go Live</strong>按钮，可以在本地启动一个服务器，同时他支持热更新，直接保存就可以刷新页面。<br>在编辑器中编辑之后直接保存，在浏览器中会自动刷新页面。<br><img src="/blog/2018/05/01/Win10-split-screen/20180501-1.gif" alt="Live Server" title="Live Server"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;巧用-Win10-分屏功能&quot;&gt;&lt;a href=&quot;#巧用-Win10-分屏功能&quot; class=&quot;headerlink&quot; title=&quot;巧用 Win10 分屏功能&quot;&gt;&lt;/a&gt;巧用 Win10 分屏功能&lt;/h1&gt;&lt;p&gt;一般我会新建三个桌面，一个看文档，一个写代码，另一个看调试结果。虽然可以在一个桌面中直接使用 &lt;code&gt;ALT + TAB&lt;/code&gt; 组合键来进行切换，但是软件多起来就会发现很乱。使用分屏会更加简洁方便。&lt;br&gt;在切换桌面可以使用 &lt;a href=&quot;http://www.yingdev.com/projects/wgestures&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WGestures&lt;/a&gt; 软件，通过鼠标触碰桌面的左上角和右上角来进行切换上下桌面。安装后可以设置一下快捷键，当然也可以直接通过&lt;code&gt;Win+Ctrl+Left/Right&lt;/code&gt;组合键来切换。如图：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="折腾记" scheme="http://zyycode.github.io/categories/%E6%8A%98%E8%85%BE%E8%AE%B0/"/>
    
      <category term="工具技巧" scheme="http://zyycode.github.io/categories/%E6%8A%98%E8%85%BE%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="折腾记" scheme="http://zyycode.github.io/tags/%E6%8A%98%E8%85%BE%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://zyycode.github.io/tags/Windows/"/>
    
      <category term="WeGrestures" scheme="http://zyycode.github.io/tags/WeGrestures/"/>
    
  </entry>
  
  <entry>
    <title>Flex 布局（二）</title>
    <link href="http://zyycode.github.io/2018/04/04/flex-layout-2/"/>
    <id>http://zyycode.github.io/2018/04/04/flex-layout-2/</id>
    <published>2018-04-04T03:58:40.000Z</published>
    <updated>2018-04-04T07:49:34.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flex-属性"><a href="#Flex-属性" class="headerlink" title="Flex 属性"></a>Flex 属性</h1><h2 id="Flex-容器属性"><a href="#Flex-容器属性" class="headerlink" title="Flex 容器属性"></a>Flex 容器属性</h2><table><thead><tr><th style="text-align:center">容器属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>flex-direction</code></td><td style="text-align:left">决定主轴的方向（即项目的排列方向）</td></tr><tr><td style="text-align:center"><code>flex-warp</code></td><td style="text-align:left">定义是否新行显示，以及新行的排列方向</td></tr><tr><td style="text-align:center"><code>flex-flow</code></td><td style="text-align:left">是 <code>flex-direction</code> 和 <code>flex-wrap</code> 的简写方式</td></tr><tr><td style="text-align:center"><code>justify-content</code></td><td style="text-align:left">定义了项目在主轴上的对齐方式</td></tr><tr><td style="text-align:center"><code>align-items</code></td><td style="text-align:left">定义弹性项目在侧轴上的对齐方式</td></tr><tr><td style="text-align:center"><code>align-content</code></td><td style="text-align:left">定义多行在侧轴的对齐方式，当只有一行时，不起作用</td></tr></tbody></table><h2 id="Flex-项目属性"><a href="#Flex-项目属性" class="headerlink" title="Flex 项目属性"></a>Flex 项目属性</h2><table><thead><tr><th style="text-align:center">项目属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>order</code></td><td style="text-align:left">数字，定义弹性项目的显示顺序，数字越小越靠前</td></tr><tr><td style="text-align:center"><code>flex-grow</code></td><td style="text-align:left">数字，定义弹性项目的放大比例，默认 0</td></tr><tr><td style="text-align:center"><code>flex-shrink</code></td><td style="text-align:left">数字，定义弹性项目的缩小比例，默认 1，值 0 表示不缩小</td></tr><tr><td style="text-align:center"><code>flex-basis</code></td><td style="text-align:left">数字，定义弹性项目的默认尺寸</td></tr><tr><td style="text-align:center"><code>flex</code></td><td style="text-align:left"><code>flex-grow</code> <code>flex-shrink</code> <code>f</code>lex-basis` 的缩写，默认值为 0 1 auto</td></tr><tr><td style="text-align:center"><code>align-self</code></td><td style="text-align:left">定义此弹性项目本身的对齐方式，会覆盖弹性容器<code>align-items</code> 定义的对齐方</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flex-属性&quot;&gt;&lt;a href=&quot;#Flex-属性&quot; class=&quot;headerlink&quot; title=&quot;Flex 属性&quot;&gt;&lt;/a&gt;Flex 属性&lt;/h1&gt;&lt;h2 id=&quot;Flex-容器属性&quot;&gt;&lt;a href=&quot;#Flex-容器属性&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Web" scheme="http://zyycode.github.io/categories/Web/"/>
    
      <category term="Flexbox" scheme="http://zyycode.github.io/categories/Web/Flexbox/"/>
    
    
      <category term="Web" scheme="http://zyycode.github.io/tags/Web/"/>
    
      <category term="前端" scheme="http://zyycode.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS布局" scheme="http://zyycode.github.io/tags/CSS%E5%B8%83%E5%B1%80/"/>
    
      <category term="Flexbox" scheme="http://zyycode.github.io/tags/Flexbox/"/>
    
  </entry>
  
  <entry>
    <title>Flex 布局（一）</title>
    <link href="http://zyycode.github.io/2018/03/09/flex-layout/"/>
    <id>http://zyycode.github.io/2018/03/09/flex-layout/</id>
    <published>2018-03-09T02:06:13.000Z</published>
    <updated>2018-05-12T07:38:25.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识-Flex"><a href="#认识-Flex" class="headerlink" title="认识 Flex"></a>认识 Flex</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前主要的前端布局方案主要有三种：</p><ul><li>传统布局方案（通过浮动、定位等方式实现）</li><li>Flex 布局方案</li><li>Grid 布局方案</li></ul><p>传统的布局方案，需要熟练掌握元素的分类及布局特性、浮动原理和定位原理等基础知识，学习成本较大，实现的复杂度也比较高。<br>Flex 布局方案，真是为了解决传统布局方案的不变，而提出的一种新型布局方案，只需要简单通过对父元素和子元素相关规则配置就能实现效果。<br>Flex 布局的主要思想是使父元素能够调节子元素的高度、宽度和排布的顺序，从而能够最好地适应可用布局空间（能够适应不同的设备和不同大小的屏幕）。设定为flex布局的元素能够放大子元素使之尽可能填充可用空间，也可以收缩子元素使之不溢出。与传统布局中块状元素按照垂直方向摆放，行内元素按照水平方向摆放相比，Flex 布局是无方向的,传统布局在应对大型复杂的布局时缺乏灵活性，特别是在改变方向、改变大小、伸展、收缩等等方面。<br>Flex 布局适合小规模的布局方案，而 Grid 布局方案适合大规模的布局方案。<br>Flex 布局的兼容性：<br><img src="/blog/2018/03/09/flex-layout/bg2015071003.jpg" alt="支持的浏览器" title="支持的浏览器"><br>总的来说，Flex 布局方案是未来的首选布局方案。</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称为“容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。<br><img src="/blog/2018/03/09/flex-layout/flex-bg-2018032801.png" alt="flex 布局" title="flex 布局"><br>容器中存在两条轴：<code>主轴</code>(main axis) 和 <code>交叉轴</code>(cross axis)。<code>主轴</code> 开始的位置为 <code>main start</code>，结束的位置为 <code>main end</code>；交叉轴开始的位置为 <code>cross start</code> ，结束的位置为 <code>cross end</code>。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做 <code>main size</code>，占据的交叉轴空间叫做 <code>cross size</code>。<br>相关概念：</p><ul><li><strong>main axis</strong>：Flex 容器的主轴。主要用来配置 Flex 项目。注意，它不一定是水平的，主要取决于 <code>flex-direction</code> 属性。</li><li><strong>main start | main end</strong>：Flex 项目的配置从容器的主轴起点边开始，往主轴终点边结束。</li><li><strong>main size</strong>：Flex项目的在主轴方向的宽度或高度就是项目的主轴长度，Flex项目的主轴长度属性是width或height属性，由哪一个对着主轴方向决定。</li><li><strong>cross axis</strong>：与主轴垂直的轴称作侧轴，是侧轴方向的延伸。</li><li><strong>cross start | cross end</strong>：伸缩行的配置从容器的侧轴起点边开始，往侧轴终点边结束。</li><li><strong>cross size</strong>：Flex 项目在侧轴方向的宽度或高度就是项目的侧轴长度，Flex项目的侧轴长度属性为width或height属性，有哪一个对着侧轴方向决定。</li></ul><h2 id="Flex-属性"><a href="#Flex-属性" class="headerlink" title="Flex 属性"></a>Flex 属性</h2><p>Flex 属性主要分为两种，<code>Flex 容器属性</code> 和 <code>Flex 项目属性</code>。父容器可以设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准。<br>Flex 容器属性：</p><ul><li>flex-direction</li><li>flex-warp</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><p><img src="/flex-layout/flex-container.png" alt="flex 容器属性" title="flex 容器属性"></p><p>Flex 项目属性</p><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul><p><img src="/flex-layout/flex-item.png" alt="flex 项目属性" title="flex 项目属性"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout" target="_blank" rel="noopener">CSS Flexible Box Layout</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a><br><a href="https://www.w3cplus.com/css3/a-guide-to-flexbox-new.html" target="_blank" rel="noopener">一个完整的Flexbox指南</a><br><a href="https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb#heading-8" target="_blank" rel="noopener">一劳永逸的搞定 flex 布局</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;认识-Flex&quot;&gt;&lt;a href=&quot;#认识-Flex&quot; class=&quot;headerlink&quot; title=&quot;认识 Flex&quot;&gt;&lt;/a&gt;认识 Flex&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;目前主要的前端布局方案主要有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传统布局方案（通过浮动、定位等方式实现）&lt;/li&gt;
&lt;li&gt;Flex 布局方案&lt;/li&gt;
&lt;li&gt;Grid 布局方案&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传统的布局方案，需要熟练掌握元素的分类及布局特性、浮动原理和定位原理等基础知识，学习成本较大，实现的复杂度也比较高。&lt;br&gt;Flex 布局方案，真是为了解决传统布局方案的不变，而提出的一种新型布局方案，只需要简单通过对父元素和子元素相关规则配置就能实现效果。&lt;br&gt;Flex 布局的主要思想是使父元素能够调节子元素的高度、宽度和排布的顺序，从而能够最好地适应可用布局空间（能够适应不同的设备和不同大小的屏幕）。设定为flex布局的元素能够放大子元素使之尽可能填充可用空间，也可以收缩子元素使之不溢出。与传统布局中块状元素按照垂直方向摆放，行内元素按照水平方向摆放相比，Flex 布局是无方向的,传统布局在应对大型复杂的布局时缺乏灵活性，特别是在改变方向、改变大小、伸展、收缩等等方面。&lt;br&gt;Flex 布局适合小规模的布局方案，而 Grid 布局方案适合大规模的布局方案。&lt;br&gt;Flex 布局的兼容性：&lt;br&gt;&lt;img src=&quot;/blog/2018/03/09/flex-layout/bg2015071003.jpg&quot; alt=&quot;支持的浏览器&quot; title=&quot;支持的浏览器&quot;&gt;&lt;br&gt;总的来说，Flex 布局方案是未来的首选布局方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://zyycode.github.io/categories/Web/"/>
    
      <category term="Flexbox" scheme="http://zyycode.github.io/categories/Web/Flexbox/"/>
    
    
      <category term="Web" scheme="http://zyycode.github.io/tags/Web/"/>
    
      <category term="前端" scheme="http://zyycode.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS布局" scheme="http://zyycode.github.io/tags/CSS%E5%B8%83%E5%B1%80/"/>
    
      <category term="Flexbox" scheme="http://zyycode.github.io/tags/Flexbox/"/>
    
  </entry>
  
  <entry>
    <title>简单 HTTP 协议</title>
    <link href="http://zyycode.github.io/2018/02/01/Http-Chapter-2/"/>
    <id>http://zyycode.github.io/2018/02/01/Http-Chapter-2/</id>
    <published>2018-02-01T13:00:40.000Z</published>
    <updated>2018-05-12T07:41:29.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的-HTTP-协议"><a href="#简单的-HTTP-协议" class="headerlink" title="简单的 HTTP 协议"></a>简单的 HTTP 协议</h1><h2 id="1-HTTP-协议用于客户端与服务端之间的通信"><a href="#1-HTTP-协议用于客户端与服务端之间的通信" class="headerlink" title="1. HTTP 协议用于客户端与服务端之间的通信"></a>1. HTTP 协议用于客户端与服务端之间的通信</h2><p>请求访问文本或图像等资源的一端称为<code>客户端</code>，而提供资源响应的一端称为<code>服务器端</code>。<br>在两台计算机之间使用 HTTP 协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端。</p><h2 id="2-通过请求和响应的交换达成通信"><a href="#2-通过请求和响应的交换达成通信" class="headerlink" title="2. 通过请求和响应的交换达成通信"></a>2. 通过请求和响应的交换达成通信</h2><h3 id="2-1-请求报文–客户端"><a href="#2-1-请求报文–客户端" class="headerlink" title="2.1 请求报文–客户端"></a>2.1 请求报文–客户端</h3><p><img src="/blog/2018/02/01/Http-Chapter-2/request-URI.png" alt="请求报文的构成" title="请求报文的构成"><br>请求报文是由<code>请求方法</code>、<code>请求 URI</code>、<code>协议版本</code>、<code>可选的请求首部字段</code>和<code>内容实体</code>构成的。<br><a id="more"></a></p><h3 id="2-2-响应报文–服务端"><a href="#2-2-响应报文–服务端" class="headerlink" title="2.2 响应报文–服务端"></a>2.2 响应报文–服务端</h3><p><img src="/blog/2018/02/01/Http-Chapter-2/answer.png" alt="响应报文的构成" title="响应报文的构成"><br>响应报文基本上由<code>协议版本</code>、<code>状态码</code>（表示请求成功或失败的数字代码）、用以解释状态码的<code>原因短语</code>、<code>可选的响应首部字段</code>以及实体<code>主体</code>构成。</p><h2 id="3-HTTP-是不保存状态的协议"><a href="#3-HTTP-是不保存状态的协议" class="headerlink" title="3. HTTP 是不保存状态的协议"></a>3. HTTP 是不保存状态的协议</h2><p>HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。<br>HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术。有了 Cookie 再用HTTP协议通信，就可以管理状态了。</p><h2 id="4-请求-URI-定位资源"><a href="#4-请求-URI-定位资源" class="headerlink" title="4. 请求 URI 定位资源"></a>4. 请求 URI 定位资源</h2><p><img src="/blog/2018/02/01/Http-Chapter-2/HTTP-URI.png" alt="URI定位资源" title="HTTP协议使用URI让客户端定位到资源"></p><h2 id="5-告知服务器意图的-HTTP-方法"><a href="#5-告知服务器意图的-HTTP-方法" class="headerlink" title="5. 告知服务器意图的 HTTP 方法"></a>5. 告知服务器意图的 HTTP 方法</h2><ul><li><a href="#1">GET：获取资源 <span class="github-emoji" title="point_down" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f447.png?v8">&#x1f447;</span></a></li><li><a href="#2">POST：传输实体主体 <span class="github-emoji" title="point_down" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f447.png?v8">&#x1f447;</span></a></li><li><a href="#3">PUT：传输文件 <span class="github-emoji" title="point_down" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f447.png?v8">&#x1f447;</span></a></li><li><a href="#4">HEAD：获得报文首部 <span class="github-emoji" title="point_down" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f447.png?v8">&#x1f447;</span></a></li><li><a href="#5">DELETE：删除文件 <span class="github-emoji" title="point_down" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f447.png?v8">&#x1f447;</span></a></li><li><a href="#6">OPTIONS：询问支持的方法 <span class="github-emoji" title="point_down" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f447.png?v8">&#x1f447;</span></a></li><li><a href="#7">TRACE：追踪路径 <span class="github-emoji" title="point_down" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f447.png?v8">&#x1f447;</span></a></li><li><a href="#8">CONNECT：要求用隧道协议连接代理 <span class="github-emoji" title="point_down" data-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f447.png?v8">&#x1f447;</span></a></li></ul><h3 id="5-1-GET：获取资源"><a href="#5-1-GET：获取资源" class="headerlink" title="5.1 GET：获取资源"></a>5.1 <a name="1">GET：获取资源</a></h3><p>GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。<br><img src="/blog/2018/02/01/Http-Chapter-2/GET.png" alt="GET 方法" title="使用 GET 方法请求-响应的例子"></p><h3 id="5-2-POST：传输实体主体"><a href="#5-2-POST：传输实体主体" class="headerlink" title="5.2 POST：传输实体主体"></a>5.2 <a name="2">POST：传输实体主体</a></h3><p>POST 方法用来传输实体的主体。相对于 GET 方法的“我想要向服务器访问某个资源” POST 方法则是“我要把这条信息告诉给服务器”。<br><img src="/blog/2018/02/01/Http-Chapter-2/GET.png" alt="POST 方法" title="使用 POST 方法请求-响应的例子"></p><h3 id="5-3-PUT：传输文件"><a href="#5-3-PUT：传输文件" class="headerlink" title="5.3 PUT：传输文件"></a>5.3 <a name="3">PUT：传输文件</a></h3><p>PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI 指定的位置。<br><img src="/blog/2018/02/01/Http-Chapter-2/PUT.png" alt="PUT 方法" title="使用 PUT 方法请求-响应的例子"></p><h3 id="5-4-HEAD：获得报文首部"><a href="#5-4-HEAD：获得报文首部" class="headerlink" title="5.4 HEAD：获得报文首部"></a>5.4 <a name="4">HEAD：获得报文首部</a></h3><p>用于确认 URI 的有效性及资源更新的日期时间等。<br><img src="/blog/2018/02/01/Http-Chapter-2/HEAD.png" alt="HEAD 方法" title="使用 PUHEADT 方法请求-响应的例子"></p><h3 id="5-5-DELETE：删除文件"><a href="#5-5-DELETE：删除文件" class="headerlink" title="5.5 DELETE：删除文件"></a>5.5 <a name="5">DELETE：删除文件</a></h3><p>DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。<br><img src="/blog/2018/02/01/Http-Chapter-2/DELETE.png" alt="DELETE 方法" title="使用 DELETE 方法请求-响应的例子"></p><h3 id="5-6-OPTIONS：询问支持的方法"><a href="#5-6-OPTIONS：询问支持的方法" class="headerlink" title="5.6 OPTIONS：询问支持的方法"></a>5.6 <a name="6">OPTIONS：询问支持的方法</a></h3><p>OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。<br><img src="/blog/2018/02/01/Http-Chapter-2/DELETE.png" alt="OPTIONS 方法" title="使用 OPTIONS 方法请求-响应的例子"></p><h3 id="5-7-TRACE：追踪路径"><a href="#5-7-TRACE：追踪路径" class="headerlink" title="5.7 TRACE：追踪路径"></a>5.7 <a name="7">TRACE：追踪路径</a></h3><p>TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。<br><img src="/blog/2018/02/01/Http-Chapter-2/TRACE-1.png" alt="TRACE 图解" title="TEACE 图解"><br>但是，TRACE 方法本来就不怎么常用，再加上它容易引发 XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。<br><img src="/blog/2018/02/01/Http-Chapter-2/TRACE-2.png" alt="TRACE 方法" title="使用 TRACE 方法请求-响应的例子"></p><h3 id="5-8-CONNECT：要求用隧道协议连接代理"><a href="#5-8-CONNECT：要求用隧道协议连接代理" class="headerlink" title="5.8 CONNECT：要求用隧道协议连接代理"></a>5.8 <a name="8">CONNECT：要求用隧道协议连接代理</a></h3><p>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CONNCET 格式</span></span><br><span class="line">CONNCET 代理服务器名：端口号 HTTP版本</span><br></pre></td></tr></table></figure></p><p><img src="/blog/2018/02/01/Http-Chapter-2/CONNECT.png" alt="CONNECT 方法" title="使用 CONNECT 方法请求-响应的例子"></p><h2 id="6-持久连接节省通信量"><a href="#6-持久连接节省通信量" class="headerlink" title="6. 持久连接节省通信量"></a>6. 持久连接节省通信量</h2><p>在 HTTP 的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。这对于一些容量很小的问本传输没有多大问题，但是随着 HTTP 的普及，文档中的文本和图片越来越多，每次请求都会造成无谓的 TCP 连接和断开，增加通信量的开销。<br><img src="/blog/2018/02/01/Http-Chapter-2/HTTP-TCP.png" alt="HTTP-TCP" title="HTTP 初始版本中的请求图"><br>这对于一些容量很小的问本传输没有多大问题，但是随着 HTTP 的普及，文档中的文本和图片越来越多，每次请求都会造成无谓的 TCP 连接和断开，增加通信量的开销。<br><img src="/blog/2018/02/01/Http-Chapter-2/HTTP-TCP-2.png" alt="HTTP-TCP" title="HTTP 初始版本中的请求图"></p><h3 id="6-1-持久连接"><a href="#6-1-持久连接" class="headerlink" title="6.1 持久连接"></a>6.1 持久连接</h3><p>为了解决上述的问题，出现了<code>持久链接</code>的方法（HTTP Persistent Connections，也称为<code>HTTP keep-alive</code> 或 <code>HTTP connection reuse</code>）的方法。特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接。<br><img src="/blog/2018/02/01/Http-Chapter-2/HTTP-Persistent-Connections.png" alt="HTTP-Persistent-Connections" title="图：持久连接旨在建立1 次TCP 连接后进行多次请求和响应的交互"></p><h3 id="6-2-管线化"><a href="#6-2-管线化" class="headerlink" title="6.2 管线化"></a>6.2 管线化</h3><p><code>管线化技术</code>：持续连接使得多数请求以管线化方式发送。这样可以做到同时并行发送多个请求，而不需要一个接一个地等待响应了。<br><img src="/blog/2018/02/01/Http-Chapter-2/pipelining.png" alt="pipelining" title="图：不等待响应，直接发送下一个请求"></p><h2 id="7-使用Cookie-的状态管理"><a href="#7-使用Cookie-的状态管理" class="headerlink" title="7. 使用Cookie 的状态管理"></a>7. 使用Cookie 的状态管理</h2><p>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。<br>Cookie 主要用于三个方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">《HTTP cookies》</a><br><a href="https://segmentfault.com/a/1190000004556040" target="_blank" rel="noopener">《聊一聊 cookie》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单的-HTTP-协议&quot;&gt;&lt;a href=&quot;#简单的-HTTP-协议&quot; class=&quot;headerlink&quot; title=&quot;简单的 HTTP 协议&quot;&gt;&lt;/a&gt;简单的 HTTP 协议&lt;/h1&gt;&lt;h2 id=&quot;1-HTTP-协议用于客户端与服务端之间的通信&quot;&gt;&lt;a href=&quot;#1-HTTP-协议用于客户端与服务端之间的通信&quot; class=&quot;headerlink&quot; title=&quot;1. HTTP 协议用于客户端与服务端之间的通信&quot;&gt;&lt;/a&gt;1. HTTP 协议用于客户端与服务端之间的通信&lt;/h2&gt;&lt;p&gt;请求访问文本或图像等资源的一端称为&lt;code&gt;客户端&lt;/code&gt;，而提供资源响应的一端称为&lt;code&gt;服务器端&lt;/code&gt;。&lt;br&gt;在两台计算机之间使用 HTTP 协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端。&lt;/p&gt;
&lt;h2 id=&quot;2-通过请求和响应的交换达成通信&quot;&gt;&lt;a href=&quot;#2-通过请求和响应的交换达成通信&quot; class=&quot;headerlink&quot; title=&quot;2. 通过请求和响应的交换达成通信&quot;&gt;&lt;/a&gt;2. 通过请求和响应的交换达成通信&lt;/h2&gt;&lt;h3 id=&quot;2-1-请求报文–客户端&quot;&gt;&lt;a href=&quot;#2-1-请求报文–客户端&quot; class=&quot;headerlink&quot; title=&quot;2.1 请求报文–客户端&quot;&gt;&lt;/a&gt;2.1 请求报文–客户端&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/blog/2018/02/01/Http-Chapter-2/request-URI.png&quot; alt=&quot;请求报文的构成&quot; title=&quot;请求报文的构成&quot;&gt;&lt;br&gt;请求报文是由&lt;code&gt;请求方法&lt;/code&gt;、&lt;code&gt;请求 URI&lt;/code&gt;、&lt;code&gt;协议版本&lt;/code&gt;、&lt;code&gt;可选的请求首部字段&lt;/code&gt;和&lt;code&gt;内容实体&lt;/code&gt;构成的。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://zyycode.github.io/categories/Web/"/>
    
      <category term="HTTP" scheme="http://zyycode.github.io/categories/Web/HTTP/"/>
    
      <category term="图解HTTP-笔记" scheme="http://zyycode.github.io/categories/Web/HTTP/%E5%9B%BE%E8%A7%A3HTTP-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Web" scheme="http://zyycode.github.io/tags/Web/"/>
    
      <category term="前端" scheme="http://zyycode.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTTP" scheme="http://zyycode.github.io/tags/HTTP/"/>
    
      <category term="学习笔记" scheme="http://zyycode.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>了解 Web 及网络基础</title>
    <link href="http://zyycode.github.io/2018/02/01/Http-Chapter-1/"/>
    <id>http://zyycode.github.io/2018/02/01/Http-Chapter-1/</id>
    <published>2018-02-01T08:15:05.000Z</published>
    <updated>2018-05-12T05:24:33.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解-Web-及网络基础"><a href="#了解-Web-及网络基础" class="headerlink" title="了解 Web 及网络基础"></a>了解 Web 及网络基础</h1><h2 id="使用-HTTP-协议访问-Web"><a href="#使用-HTTP-协议访问-Web" class="headerlink" title="使用 HTTP 协议访问 Web"></a>使用 HTTP 协议访问 Web</h2><p>当我们使用浏览器时，在地址栏输入<a href="https://www.baidu.com/" target="_blank" rel="noopener">www.baidu.com</a>后，页面信息是如何呈现的呢？其实当我们在地址栏输入<code>URL</code>后，浏览器就会从服务器获取文件资源等信息，然后显示到浏览器上面。就比如，卖家在网上买东西，选购填写自己的地址信息后，然后卖家会根据你的地址通过快递公司发货给你，地址信息就相当于<code>URL</code>，卖家就相当于服务器，买家就相当于浏览器，快递公司就相当于传输协议（<code>HTTP协议</code>）。<br><img src="/blog/2018/02/01/Http-Chapter-1/web.png" alt=""><br>HTTP（HyperText Transfer Protocol，超文本传输协议，严谨来说应该叫超文本转移协议），完成从客户端到服务端等一系列运作流程。可以说，Web 是建立在 HTTP 协议上通信的。</p><a id="more"></a><h2 id="网络基础-TCP-IP"><a href="#网络基础-TCP-IP" class="headerlink" title="网络基础 TCP/IP"></a>网络基础 TCP/IP</h2><h3 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h3><p><code>协议</code>: 不同的硬件、操作系统之间的通信规则。<br><code>TCP/IP</code>: 与互联网相关的协议的集合。<br><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/blog/2018/02/01/Http-Chapter-1/TCP-IP.png" class="full-image" alt="alt" title="图：TCP/IP 是互联网相关的各类协议族的总称"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></p><h3 id="TCP-IP-分层管理"><a href="#TCP-IP-分层管理" class="headerlink" title="TCP/IP 分层管理"></a>TCP/IP 分层管理</h3><ul><li>应用层：决定了向用户提供应用服务时通信的活动</li><li>传输层：对上层应用层，提供处于网络连接中的两台计算机之间的数据传输</li><li>网络层（网络互连层）：处理在网络上流动的数据包</li><li>链路层（数据链路层，网络接口层）：处理连接网络的硬件部分</li></ul><h3 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP/IP 通信传输流"></a>TCP/IP 通信传输流</h3><p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行<br>通信。发送端从应用层往下走，接收端则往应用层往上走。<br><img src="/blog/2018/02/01/Http-Chapter-1/TCP-IP-2.png" alt=""><br>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个<br>该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据包装起来的做法称为<code>封装</code>。</p><h2 id="与HTTP-关系密切的协议：IP、TCP-和-DNS"><a href="#与HTTP-关系密切的协议：IP、TCP-和-DNS" class="headerlink" title="与HTTP 关系密切的协议：IP、TCP 和 DNS"></a>与HTTP 关系密切的协议：IP、TCP 和 DNS</h2><h3 id="负责传输的-IP-协议"><a href="#负责传输的-IP-协议" class="headerlink" title="负责传输的 IP 协议"></a>负责传输的 IP 协议</h3><p><code>IP</code>是一种协议的名称；<code>IP地址</code>是一串数字。IP协议的作用是把各种数据包传送给对方。IP 地址和 MAC 地址时确保传输到对方的两个重要条件。<br>在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的IP 地址就可以反查出对应的 MAC 地址。<br><img src="/blog/2018/02/01/Http-Chapter-1/IP.png" alt=""></p><h3 id="确保可靠性的-TCP-协议"><a href="#确保可靠性的-TCP-协议" class="headerlink" title="确保可靠性的 TCP 协议"></a>确保可靠性的 TCP 协议</h3><p>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。<br><img src="/blog/2018/02/01/Http-Chapter-1/TCP.png" alt=""></p><h3 id="负责域名解析的-DNS-服务"><a href="#负责域名解析的-DNS-服务" class="headerlink" title="负责域名解析的 DNS 服务"></a>负责域名解析的 DNS 服务</h3><p>DNS（Domain Name System）服务是和HTTP协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。<br><img src="/blog/2018/02/01/Http-Chapter-1/DNS.png" alt=""></p><h2 id="各种协议与-HTTP-协议的关系"><a href="#各种协议与-HTTP-协议的关系" class="headerlink" title="各种协议与 HTTP 协议的关系"></a>各种协议与 HTTP 协议的关系</h2><p><img src="/blog/2018/02/01/Http-Chapter-1/HTTP-TCPIP-DNS.png" alt=""></p><h2 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h2><p><code>URI</code>：统一资源标识符(Uniform Resource Indentifier)用来标识服务器上的资源。<br><code>URL</code>:统一资源定位符(Uniform Resouce Locator)是资源标识符最常见的表示格式。<br>URL时URI的子集。<br>区别：URI 定义资源，而 URL 不单定义这个资源，还定义了如何找到这个资源（即访问资源的方式）。</p><p><strong>参考：</strong><br><a href="https://www.zhihu.com/question/21950864" target="_blank" rel="noopener">《HTTP 协议中 URI 和 URL 有什么区别？》</a></p><h3 id="绝对-URI-格式"><a href="#绝对-URI-格式" class="headerlink" title="绝对 URI 格式"></a>绝对 URI 格式</h3><p><img src="/blog/2018/02/01/Http-Chapter-1/URI.png" alt=""></p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">《图解HTTP》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;了解-Web-及网络基础&quot;&gt;&lt;a href=&quot;#了解-Web-及网络基础&quot; class=&quot;headerlink&quot; title=&quot;了解 Web 及网络基础&quot;&gt;&lt;/a&gt;了解 Web 及网络基础&lt;/h1&gt;&lt;h2 id=&quot;使用-HTTP-协议访问-Web&quot;&gt;&lt;a href=&quot;#使用-HTTP-协议访问-Web&quot; class=&quot;headerlink&quot; title=&quot;使用 HTTP 协议访问 Web&quot;&gt;&lt;/a&gt;使用 HTTP 协议访问 Web&lt;/h2&gt;&lt;p&gt;当我们使用浏览器时，在地址栏输入&lt;a href=&quot;https://www.baidu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.baidu.com&lt;/a&gt;后，页面信息是如何呈现的呢？其实当我们在地址栏输入&lt;code&gt;URL&lt;/code&gt;后，浏览器就会从服务器获取文件资源等信息，然后显示到浏览器上面。就比如，卖家在网上买东西，选购填写自己的地址信息后，然后卖家会根据你的地址通过快递公司发货给你，地址信息就相当于&lt;code&gt;URL&lt;/code&gt;，卖家就相当于服务器，买家就相当于浏览器，快递公司就相当于传输协议（&lt;code&gt;HTTP协议&lt;/code&gt;）。&lt;br&gt;&lt;img src=&quot;/blog/2018/02/01/Http-Chapter-1/web.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;HTTP（HyperText Transfer Protocol，超文本传输协议，严谨来说应该叫超文本转移协议），完成从客户端到服务端等一系列运作流程。可以说，Web 是建立在 HTTP 协议上通信的。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://zyycode.github.io/categories/Web/"/>
    
      <category term="HTTP" scheme="http://zyycode.github.io/categories/Web/HTTP/"/>
    
      <category term="图解HTTP-笔记" scheme="http://zyycode.github.io/categories/Web/HTTP/%E5%9B%BE%E8%A7%A3HTTP-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Web" scheme="http://zyycode.github.io/tags/Web/"/>
    
      <category term="前端" scheme="http://zyycode.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTTP" scheme="http://zyycode.github.io/tags/HTTP/"/>
    
      <category term="学习笔记" scheme="http://zyycode.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Windows 下使用tree命令生成目录树</title>
    <link href="http://zyycode.github.io/2018/01/29/Windows-tree/"/>
    <id>http://zyycode.github.io/2018/01/29/Windows-tree/</id>
    <published>2018-01-29T10:23:48.000Z</published>
    <updated>2018-05-12T05:27:11.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h1><p>在看<a href="https://cn.vuejs.org/v2/guide/instance.html" target="_blank" rel="noopener">Vue.js</a>的官方文档时，看到了这样的目录图，当时就好奇这是怎么写出来的，是由专门的语法还是通过手打出来的，于是就上网查找，发现原来这是通过<code>tree</code>命令来实现。<br><img src="/blog/2018/01/29/Windows-tree/todo-item.png" alt=""></p><a id="more"></a><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>tree命令格式:<br><code>TREE [drive:][path] [/F] [/A]</code></p><blockquote><p>/F 显示每个文件夹中文件的名称。使用时显示所有目录及目录下的所有文件，省略时，只显示目录，不显示目录下的文件;<br>/A 使用 ASCII 字符，而不使用扩展字符。</p></blockquote><p>在 <code>Linux</code> 和 <code>Mac OS</code> 系统中tree命令有更强大的功能，但在Windows下只有 <code>/F</code> <code>/A</code></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>OK，Let’s do it now ! 😄<br>首先，建立相关的测试文件夹<br><img src="/blog/2018/01/29/Windows-tree/tree-file.png" alt=""><br>然后在DOS中进入目录 <code>E:\test&gt;</code><br>输入相关命令，你可以选择在DOS中直接显示，也可以存为txt文件<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tree</span> /f              <span class="comment">// 直接显示</span></span><br><span class="line"><span class="keyword">tree</span> /f &gt; <span class="keyword">tree</span>.txt   <span class="comment">// 存为txt文件</span></span><br></pre></td></tr></table></figure></p><p>结果：<br><img src="/blog/2018/01/29/Windows-tree/tree-txt.png" alt=""><br>之后就可以复制其中的内容了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">└─ToDoList</span><br><span class="line">    ├─ToDoItem</span><br><span class="line">    │  ├─DeleteToDoButton</span><br><span class="line">    │  └─EditToDoButton</span><br><span class="line">    └─ToDoListFooter</span><br><span class="line">        ├─ClearToDoButton</span><br><span class="line">        └─ToDoListStatistics</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;了解&quot;&gt;&lt;a href=&quot;#了解&quot; class=&quot;headerlink&quot; title=&quot;了解&quot;&gt;&lt;/a&gt;了解&lt;/h1&gt;&lt;p&gt;在看&lt;a href=&quot;https://cn.vuejs.org/v2/guide/instance.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue.js&lt;/a&gt;的官方文档时，看到了这样的目录图，当时就好奇这是怎么写出来的，是由专门的语法还是通过手打出来的，于是就上网查找，发现原来这是通过&lt;code&gt;tree&lt;/code&gt;命令来实现。&lt;br&gt;&lt;img src=&quot;/blog/2018/01/29/Windows-tree/todo-item.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="折腾记" scheme="http://zyycode.github.io/categories/%E6%8A%98%E8%85%BE%E8%AE%B0/"/>
    
      <category term="工具技巧" scheme="http://zyycode.github.io/categories/%E6%8A%98%E8%85%BE%E8%AE%B0/%E5%B7%A5%E5%85%B7%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="折腾记" scheme="http://zyycode.github.io/tags/%E6%8A%98%E8%85%BE%E8%AE%B0/"/>
    
      <category term="windows" scheme="http://zyycode.github.io/tags/windows/"/>
    
      <category term="tree命令" scheme="http://zyycode.github.io/tags/tree%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript知识点（一）</title>
    <link href="http://zyycode.github.io/2017/12/02/JavaScript/"/>
    <id>http://zyycode.github.io/2017/12/02/JavaScript/</id>
    <published>2017-12-02T11:40:40.000Z</published>
    <updated>2018-03-09T02:07:38.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量类型及计算"><a href="#变量类型及计算" class="headerlink" title="变量类型及计算"></a>变量类型及计算</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="1-JS中用-typeof-得到那些数据类型"><a href="#1-JS中用-typeof-得到那些数据类型" class="headerlink" title="1. JS中用 typeof 得到那些数据类型"></a>1. JS中用 <code>typeof</code> 得到那些数据类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>     <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'123'</span>         <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>           <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>          <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;            <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> []            <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>          <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log() <span class="comment">//function</span></span><br></pre></td></tr></table></figure><blockquote><p>typeof 只能区分值类型</p></blockquote><a id="more"></a><h3 id="2-何时使用-和"><a href="#2-何时使用-和" class="headerlink" title="2. 何时使用 == 和 ==="></a>2. 何时使用 <code>==</code> 和 <code>===</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj.a == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里相当于 obj.a === null || obj.a === undefined, 简写形式</span></span><br><span class="line"><span class="comment">        这是jQuery源码的推荐写法</span></span><br><span class="line"><span class="comment">        除此之外都是用 ===</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里也可以使用 == ,但是 == 之前的变量必须要有定义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>‘’(空字符串), 0, null, undefined都可以转换为 false</p></blockquote><h3 id="3-JS中的内置函数–数据封装对象"><a href="#3-JS中的内置函数–数据封装对象" class="headerlink" title="3. JS中的内置函数–数据封装对象"></a>3. JS中的内置函数–数据封装对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span></span><br><span class="line"><span class="built_in">Number</span></span><br><span class="line"><span class="built_in">String</span></span><br><span class="line"><span class="built_in">Boolean</span></span><br><span class="line"><span class="built_in">Function</span></span><br><span class="line"><span class="built_in">Array</span></span><br><span class="line"><span class="built_in">Date</span></span><br><span class="line"><span class="built_in">RegExp</span></span><br><span class="line"><span class="built_in">Error</span></span><br></pre></td></tr></table></figure><h3 id="4-JS变量按存储方式区分为那些类型，并描述其特点"><a href="#4-JS变量按存储方式区分为那些类型，并描述其特点" class="headerlink" title="4. JS变量按存储方式区分为那些类型，并描述其特点"></a>4. JS变量按存储方式区分为那些类型，并描述其特点</h3><ul><li><p>值类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure></li><li><p>引用类型：对象、数组、函数（节省内存空间，以指针方式存储）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">x</span>: <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj1.x = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.x) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-如何理解JSON"><a href="#5-如何理解JSON" class="headerlink" title="5. 如何理解JSON"></a>5. 如何理解JSON</h3><p>JSON只是JS的一个内置对象，Math也是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stingify(&#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>&#125;) <span class="comment">// 对象 -&gt; 字符串</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">"&#123;'a': 10, 'b': 20&#125;"</span>) <span class="comment">// 字符串 -&gt; 对象</span></span><br></pre></td></tr></table></figure></p><h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>构造函数</li><li>构造函数 - 扩展</li><li>原型规则和示例</li><li>原型链</li><li>instanceof</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.class = <span class="string">'class one'</span>;</span><br><span class="line">    <span class="comment">//return this  //默认有这一行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建多个对象</span></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo(<span class="string">'zhansan'</span>, <span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> Foo(<span class="string">'lise'</span>, <span class="number">13</span>);</span><br></pre></td></tr></table></figure><h3 id="构造函数的扩展"><a href="#构造函数的扩展" class="headerlink" title="构造函数的扩展"></a>构造函数的扩展</h3><ul><li><code>var a = {}</code> 其实是 <code>var a = new Object()</code> 的语法糖</li><li><code>var a = []</code> 其实是 <code>var a = new Array()</code> 的语法糖</li><li><code>function Foo() {...}</code> 其实是 <code>var Foo = new Funcion() {...}</code> 的语法糖</li><li>使用 <code>instanceof</code> 判断一个函数是否是一个变量的构造函数</li></ul><h3 id="原型规则和实例"><a href="#原型规则和实例" class="headerlink" title="原型规则和实例"></a>原型规则和实例</h3><ul><li>所有的引用类型（对象、数组、函数），都具有对象特性，即可自由扩展属性（除了”null”以外</li><li>所有的引用类型（对象、数组、函数），都有一个proto(隐式原型)属性，属性值是一个普通对象</li><li>所有的函数，都有一个prototype(显示原型)属性，属性值是一个普通对象</li><li>所有的引用类型（对象、数组、函数），proto属性值指向它的构造函数的 <code>prototype</code> 属性值</li><li>当试图寻找一个对象（引用类型）的某个属性时，如果这个对象本身没有这个睡醒，那么会去它的proto（即它的构造函数的prototype）中去寻找</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有的引用类型都有可自由扩展属性</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> arr =[];</span><br><span class="line">arr.a = <span class="number">200</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">fn.a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的引用类型都有一个默认的隐式原型属性</span></span><br><span class="line"><span class="built_in">console</span>.log(obj._proto_);</span><br><span class="line"><span class="built_in">console</span>.log(arr._proto_);</span><br><span class="line"><span class="built_in">console</span>.log(fn._proto_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的函数都有一个显示原型的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(fn.prototype);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有引用类型的_proto_属性值指向它的构造函数的prototype属性值</span></span><br><span class="line"><span class="built_in">console</span>.log(obj._proto_ === <span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.alertName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'zhangsan'</span>);</span><br><span class="line">f.printName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">f.alertName();</span><br><span class="line">f.printName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环对象自身的属性</span></span><br><span class="line"><span class="keyword">var</span> item;</span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> f) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        高级浏览器已经在 for in 中屏蔽了来自原型的属性</span></span><br><span class="line"><span class="comment">        但还是建议加上下面这个判断，保证程序的健壮性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (f.hasOwnProperty(item)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链</span></span><br><span class="line">f.toString() <span class="comment">// 要去 f._proto_._proto_ 中查找</span></span><br></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>用于判断<strong>引用类型</strong>属于哪个<strong>构造函数</strong>的方法<br>f <code>intanceof</code> Foo 的判断逻辑：</p><ul><li><code>f.proto</code> 一层一层往上，能否对应到 <code>Foo.prototype</code></li><li>再试着判断 <code>f instanceof Object</code></li><li>同样在 <code>f.proto</code> 一层一层往上找，直到 <code>Object.prototype</code></li></ul><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><h3 id="1-如何准确判断一个变量是数组类型"><a href="#1-如何准确判断一个变量是数组类型" class="headerlink" title="1. 如何准确判断一个变量是数组类型"></a>1. 如何准确判断一个变量是数组类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> arr; <span class="comment">// Object, typeof 是无法判断是否为数组的</span></span><br></pre></td></tr></table></figure><h3 id="2-写一个原型链继承的例子"><a href="#2-写一个原型链继承的例子" class="headerlink" title="2. 写一个原型链继承的例子"></a>2. 写一个原型链继承的例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动物</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Animal eat'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 狗</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bark = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dog bark'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="comment">// 哈士奇</span></span><br><span class="line"><span class="keyword">var</span> hashiqi = <span class="keyword">new</span> Dog();</span><br><span class="line">hashiqi.eat();</span><br><span class="line">hashiqi.bark();</span><br></pre></td></tr></table></figure><blockquote><p><strong>面试中千万不要上面的例子，应该写更加贴近实战的例子，上面这个例子只是用来理解。</strong></p></blockquote><p>一个封装DOM查询的例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Elem</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.Elem = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">&#125;</span><br><span class="line">Elem.prototype.html = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elem = <span class="keyword">this</span>. Elem;</span><br><span class="line">    <span class="keyword">if</span> (val) &#123;</span><br><span class="line">        elem.innerHTML = val;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> elem.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Elem.prototype.on = <span class="function"><span class="keyword">function</span> (<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elem = <span class="keyword">this</span>.Elem;</span><br><span class="line">    elem.addEventListener(type, fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> div1 = <span class="keyword">new</span> Elem(<span class="string">'div1'</span>);</span><br><span class="line">div.html(<span class="string">'&lt;p&gt;hello&lt;/p&gt;'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;alert(<span class="string">'clicked'</span>)&#125;).html(<span class="string">'&lt;p&gt;JavaScript&lt;/p&gt;'</span>);</span><br></pre></td></tr></table></figure></p><h3 id="3-描述-new-一个对象的过程"><a href="#3-描述-new-一个对象的过程" class="headerlink" title="3. 描述 new 一个对象的过程"></a>3. 描述 new 一个对象的过程</h3><ul><li>创建一个新对象</li><li>this 指向这个新对象</li><li>执行代码，即对 this 进行赋值</li><li>返回 this</li></ul><h3 id="4-zepto-或其他框架-源码中如何使用原型链"><a href="#4-zepto-或其他框架-源码中如何使用原型链" class="headerlink" title="4. zepto(或其他框架)源码中如何使用原型链"></a>4. zepto(或其他框架)源码中如何使用原型链</h3><ul><li>阅读源码是高效提升技能的方式</li><li>但不能“埋头苦研”有技巧在其中，阅读之前在网上先搜索一下资料</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;变量类型及计算&quot;&gt;&lt;a href=&quot;#变量类型及计算&quot; class=&quot;headerlink&quot; title=&quot;变量类型及计算&quot;&gt;&lt;/a&gt;变量类型及计算&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;h3 id=&quot;1-JS中用-typeof-得到那些数据类型&quot;&gt;&lt;a href=&quot;#1-JS中用-typeof-得到那些数据类型&quot; class=&quot;headerlink&quot; title=&quot;1. JS中用 typeof 得到那些数据类型&quot;&gt;&lt;/a&gt;1. JS中用 &lt;code&gt;typeof&lt;/code&gt; 得到那些数据类型&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;     &lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;123&#39;&lt;/span&gt;         &lt;span class=&quot;comment&quot;&gt;// string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;           &lt;span class=&quot;comment&quot;&gt;// number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;          &lt;span class=&quot;comment&quot;&gt;// boolean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &amp;#123;&amp;#125;            &lt;span class=&quot;comment&quot;&gt;// object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; []            &lt;span class=&quot;comment&quot;&gt;// object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;          &lt;span class=&quot;comment&quot;&gt;// object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log() &lt;span class=&quot;comment&quot;&gt;//function&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;typeof 只能区分值类型&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Web" scheme="http://zyycode.github.io/categories/Web/"/>
    
      <category term="JavaScript" scheme="http://zyycode.github.io/categories/Web/JavaScript/"/>
    
    
      <category term="Web" scheme="http://zyycode.github.io/tags/Web/"/>
    
      <category term="前端" scheme="http://zyycode.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://zyycode.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hello-Hexo</title>
    <link href="http://zyycode.github.io/2017/11/05/Hello-Hexo/"/>
    <id>http://zyycode.github.io/2017/11/05/Hello-Hexo/</id>
    <published>2017-11-05T07:16:08.000Z</published>
    <updated>2018-05-12T05:22:12.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>官网地址：<a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a></p><h2 id="安装-nodejs-和-git"><a href="#安装-nodejs-和-git" class="headerlink" title="安装 nodejs 和 git"></a>安装 <code>nodejs</code> 和 <code>git</code></h2><p>在使用Hexo之前，必须要先安装<a href="http://nodejs.cn/" target="_blank" rel="noopener">node.js</a>和<a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>,下载完之后和一般安装软件一样点击下一步就可以。安装完之后打开命令提示符或者 <code>WIN + R</code> 输入 <code>cmd</code>,输入 <code>node -v</code>,若成功则下图所示:<br><img src="/blog/2017/11/05/Hello-Hexo/node-test.png" alt=""></p><a id="more"></a><p>在开始菜单中找到 <code>Git -&gt; Git Bush</code>,则安装成功。<br><img src="/blog/2017/11/05/Hello-Hexo/git-test.png" alt=""></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo官网</a>中，可查看相关命令来进行下载安装，通过文档来进行使用，简单易上手。<br><img src="/blog/2017/11/05/Hello-Hexo/hexo-use.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Hexo使用命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-cli -g <span class="comment">#在全局下安装`hexo-cli`</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init blog          <span class="comment">#在当前地址创建`blog`文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> blog                 <span class="comment">#进入到`blog`文件中</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install             <span class="comment">#使用`npm`进行安装</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo server             <span class="comment">#在本次启动服务器进行预览</span></span></span><br></pre></td></tr></table></figure><p>安装完之后可以在blog文件夹中看到相关文件:<br><img src="/blog/2017/11/05/Hello-Hexo/hexo-file.png" alt=""><br><div class="note info"><p>具体使用可查看<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a> </p></div></p><h1 id="Hexo部署到Github"><a href="#Hexo部署到Github" class="headerlink" title="Hexo部署到Github"></a>Hexo部署到Github</h1><h2 id="在Github上注册账号"><a href="#在Github上注册账号" class="headerlink" title="在Github上注册账号"></a>在Github上注册账号</h2><h2 id="新建-username-github-io-仓库"><a href="#新建-username-github-io-仓库" class="headerlink" title="新建 username.github.io 仓库"></a>新建 <code>username.github.io</code> 仓库</h2><h2 id="进入Github网站，输入你的账号密码后点击-New-repository"><a href="#进入Github网站，输入你的账号密码后点击-New-repository" class="headerlink" title="进入Github网站，输入你的账号密码后点击 New repository"></a>进入Github网站，输入你的账号密码后点击 <code>New repository</code></h2><p><img src="/blog/2017/11/05/Hello-Hexo/github-new.png" alt=""></p><h2 id="点击完之后，填写相关信息创建该仓库"><a href="#点击完之后，填写相关信息创建该仓库" class="headerlink" title="点击完之后，填写相关信息创建该仓库"></a>点击完之后，填写相关信息创建该仓库</h2><p><img src="/blog/2017/11/05/Hello-Hexo/github-create.png" alt=""></p><h2 id="在本地生成静态文件"><a href="#在本地生成静态文件" class="headerlink" title="在本地生成静态文件"></a>在本地生成静态文件</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> hexo new <span class="string">"post-name"</span>  <span class="comment">//新建一片文章</span></span><br><span class="line"><span class="symbol">$</span> hexo genernate        <span class="comment">//生成静态文件在public文件家中</span></span><br><span class="line"><span class="symbol">$</span> hexo deploy           <span class="comment">//上传到GitHub上</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>在每次 <code>hexo g</code> 前最好先使用 <code>hexo clean</code></strong></p></blockquote><h2 id="使用-hexo-deploy-上传到GitHub"><a href="#使用-hexo-deploy-上传到GitHub" class="headerlink" title="使用 hexo deploy 上传到GitHub"></a>使用 <code>hexo deploy</code> 上传到GitHub</h2><p>可能会出现22号端口链接错误，需要进行git配置：</p><ol><li>生成 <code>ssh密钥</code></li><li>在你的GitHub账户中添加生成的ssh密钥</li><li>在本地的 <code>~/.ssh</code>文件夹中建立 <code>config</code> 文件，并添加：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line"> <span class="built_in"> Port </span>443</span><br></pre></td></tr></table></figure></li></ol><p>在上传之前需要在 <code>站点配置文件</code> 中修改地址<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">url:</span> <span class="string">http:</span><span class="comment">//zyycode.github.io</span></span><br><span class="line"><span class="string">root:</span> /</span><br></pre></td></tr></table></figure></p><h2 id="使用GitHub-Desktop上传"><a href="#使用GitHub-Desktop上传" class="headerlink" title="使用GitHub Desktop上传"></a>使用GitHub Desktop上传</h2><p><a href="https://desktop.github.com/" target="_blank" rel="noopener">下载Github Desktop</a><br>选择 <code>file -&gt; clone repository</code> 在本地创建仓库后，然后将你 <code>public</code> 文件夹中的文件拷贝中刚克隆的 <code>zyycode.github.io</code> 文件中。<br><img src="/blog/2017/11/05/Hello-Hexo/github-desktop.png" alt=""><br><img src="/blog/2017/11/05/Hello-Hexo/github-desktop-use.png" alt=""></p><h2 id="在浏览中输入域名访问网站"><a href="#在浏览中输入域名访问网站" class="headerlink" title="在浏览中输入域名访问网站"></a>在浏览中输入域名访问网站</h2><p>完成之后就可以在浏览器中输入<a href="https://zyycode.github.io/">https://zyycode.github.io/</a>就可以查看你的博客了</p><h1 id="Hexo进阶使用"><a href="#Hexo进阶使用" class="headerlink" title="Hexo进阶使用"></a>Hexo进阶使用</h1><h2 id="Hexo更改主题"><a href="#Hexo更改主题" class="headerlink" title="Hexo更改主题"></a>Hexo更改主题</h2><blockquote><p>我使用的是<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next主题</a></p></blockquote><p>在<code>Hexo主题</code> 选择你喜欢的主题，可以选择 <code>git</code> 下载 或者直接克隆下载文件到你的 <code>~\blog\themes</code> 目录下,同时在 <code>站点配置文件</code> 中修改。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: <span class="keyword">next</span></span><br></pre></td></tr></table></figure></p><h2 id="添加分类页面和标签页面"><a href="#添加分类页面和标签页面" class="headerlink" title="添加分类页面和标签页面"></a>添加分类页面和标签页面</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new<span class="built_in"> page </span>categories</span><br><span class="line">$ hexo new<span class="built_in"> page </span>tags</span><br></pre></td></tr></table></figure><p><a href="http://theme-next.iissnan.com/theme-settings.html#categories-page" target="_blank" rel="noopener">新建分类页面</a><br><a href="http://theme-next.iissnan.com/theme-settings.html#tags-page" target="_blank" rel="noopener">新建标签页面</a></p><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a><a href="http://theme-next.iissnan.com/third-party-services.html#local-search" target="_blank" rel="noopener">搜索功能</a></h2><h2 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a><a href="http://theme-next.iissnan.com/third-party-services.html#comment-system" target="_blank" rel="noopener">评论功能</a></h2><h2 id="赞赏功能"><a href="#赞赏功能" class="headerlink" title="赞赏功能"></a><a href="http://theme-next.iissnan.com/theme-settings.html#reward" target="_blank" rel="noopener">赞赏功能</a></h2><h2 id="腾讯404工艺页面"><a href="#腾讯404工艺页面" class="headerlink" title="腾讯404工艺页面"></a><a href="http://theme-next.iissnan.com/theme-settings.html#volunteer-404" target="_blank" rel="noopener">腾讯404工艺页面</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hexo&quot;&gt;&lt;a href=&quot;#Hexo&quot; class=&quot;headerlink&quot; title=&quot;Hexo&quot;&gt;&lt;/a&gt;Hexo&lt;/h1&gt;&lt;p&gt;官网地址：&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hexo.io/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装-nodejs-和-git&quot;&gt;&lt;a href=&quot;#安装-nodejs-和-git&quot; class=&quot;headerlink&quot; title=&quot;安装 nodejs 和 git&quot;&gt;&lt;/a&gt;安装 &lt;code&gt;nodejs&lt;/code&gt; 和 &lt;code&gt;git&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;在使用Hexo之前，必须要先安装&lt;a href=&quot;http://nodejs.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;node.js&lt;/a&gt;和&lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git&lt;/a&gt;,下载完之后和一般安装软件一样点击下一步就可以。安装完之后打开命令提示符或者 &lt;code&gt;WIN + R&lt;/code&gt; 输入 &lt;code&gt;cmd&lt;/code&gt;,输入 &lt;code&gt;node -v&lt;/code&gt;,若成功则下图所示:&lt;br&gt;&lt;img src=&quot;/blog/2017/11/05/Hello-Hexo/node-test.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo建站" scheme="http://zyycode.github.io/categories/Hexo%E5%BB%BA%E7%AB%99/"/>
    
    
      <category term="建站" scheme="http://zyycode.github.io/tags/%E5%BB%BA%E7%AB%99/"/>
    
      <category term="Hexo" scheme="http://zyycode.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Shadowsocks Setup</title>
    <link href="http://zyycode.github.io/2017/10/20/Shadowsocks-setup/"/>
    <id>http://zyycode.github.io/2017/10/20/Shadowsocks-setup/</id>
    <published>2017-10-20T01:35:35.000Z</published>
    <updated>2018-05-12T05:26:08.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搬瓦工服务器搭建与使用"><a href="#搬瓦工服务器搭建与使用" class="headerlink" title="搬瓦工服务器搭建与使用"></a>搬瓦工服务器搭建与使用</h1><p>花费了一天的时间来搭建搬瓦工服务器一家Shadowsocks的配置，主要过程为：</p><ul><li>购买 <a href="https://bandwagonhost.com/" target="_blank" rel="noopener">搬瓦工服务器</a> <a href="http://banwagong.cn/" target="_blank" rel="noopener">国内镜像网站</a>!</li><li>在服务器上使用一键安装Shadowsocks功能</li><li>客户端上安装Shadosocks软件</li></ul><a id="more"></a><h2 id="购买BandwagongHost（俗称搬瓦工）服务器"><a href="#购买BandwagongHost（俗称搬瓦工）服务器" class="headerlink" title="购买BandwagongHost（俗称搬瓦工）服务器"></a>购买BandwagongHost（俗称搬瓦工）服务器</h2><p><img src="/blog/2017/10/20/Shadowsocks-setup/bang-website.png" alt=""><br>购买时选择KVM架构的服务器，因为可以选择安装<code>centos-6-x86_64-bbr</code> 系统（默认安装，加速），同时还可以选择其他加速方式，两者的主要区别是：<br>OpenVZ advantages:</p><ul><li>IPv6 support</li><li>Better CPU performance<br>KVM advantages:</li><li>Full virtualization</li><li>Custom kernel support (BBR, etc)</li><li>Docker support</li><li>Better isolation</li><li>Better network throughput<br><img src="/blog/2017/10/20/Shadowsocks-setup/buy.png" alt=""><br>点击购买就可以了,可以选择支付宝付款。购买成功之后会选择发送邮件到你注册时使用的邮箱中，具体信息可以登入到网站中查看<br><img src="/blog/2017/10/20/Shadowsocks-setup/login.png" alt=""><br><img src="/blog/2017/10/20/Shadowsocks-setup/login-server.png" alt=""><br>在服务器中先选择安装系统，最好安装<code>centos-6 x86系统</code>，然后可以选择一件安装<code>Shadowsocks Serve</code>r,安装完之后会显示端口、密码等相关信息，这些信息是填写客户端（PC端）上面。<h2 id="客户端安装Shadowsocks"><a href="#客户端安装Shadowsocks" class="headerlink" title="客户端安装Shadowsocks"></a>客户端安装Shadowsocks</h2>windows版安装就和平时安装软件一样，点击下一步就可以，安装完之后填写服务器、密码、端口号相关信息就可以了。<br>下载地址：<a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">官方下载页</a><br><img src="/blog/2017/10/20/Shadowsocks-setup/ss.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;搬瓦工服务器搭建与使用&quot;&gt;&lt;a href=&quot;#搬瓦工服务器搭建与使用&quot; class=&quot;headerlink&quot; title=&quot;搬瓦工服务器搭建与使用&quot;&gt;&lt;/a&gt;搬瓦工服务器搭建与使用&lt;/h1&gt;&lt;p&gt;花费了一天的时间来搭建搬瓦工服务器一家Shadowsocks的配置，主要过程为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;购买 &lt;a href=&quot;https://bandwagonhost.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;搬瓦工服务器&lt;/a&gt; &lt;a href=&quot;http://banwagong.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;国内镜像网站&lt;/a&gt;!&lt;/li&gt;
&lt;li&gt;在服务器上使用一键安装Shadowsocks功能&lt;/li&gt;
&lt;li&gt;客户端上安装Shadosocks软件&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://zyycode.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="VPS Shadowsocks" scheme="http://zyycode.github.io/categories/%E6%8A%80%E6%9C%AF/VPS-Shadowsocks/"/>
    
    
      <category term="技术" scheme="http://zyycode.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="VPS Shadowsocks" scheme="http://zyycode.github.io/tags/VPS-Shadowsocks/"/>
    
  </entry>
  
</feed>
